<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.11">
  <POU Name="FB_Instrument" Id="{851fd539-e88c-4a52-b2dc-b810ec435a75}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_Instrument

VAR_IN_OUT CONSTANT
	i_slaveArm	:FB_SlaveArm;
END_VAR

VAR
	// instrument type
	m_instruType : 	E_InstrumentType := InstruType_UNKNOWM;
	
	// instrument type info
	m_instruTypeInfo : 	ST_InstruTypeInfo;
	
	//The state and parameters readed from the instrument
	m_onChipData:ST_InstruOnChipData;
	
	// current and max allowed read tries
	m_curReadTries :INT :=0;
	m_maxReadTries :INT := 20;
	
	//IP of operating arm
	m_armNetId:T_AmsNetId; 	
	
	//Joint port number
	m_jointInstruAddr:UINT;	
	
	//LED port address
	m_LEDAddr:UINT;		

	// joint position when instrument is at ZERO posture
	m_jntPosOffset:Vec8d;
	
	// instrument wrist DH joint limit
	m_wristMinDHJntPos :Vec3d;
	m_wristMaxDHJntPos :Vec3d;
	
	// reduction from motor joint to endoscope rotate joint
	m_endoscopeRotateReduction :LREAL := 2.0/3.0;
	
	//endoscope type
	m_curEndoscopeType :E_EndoscopeType:=EndoScopeType_30;
	m_nextEndoscopeType :E_EndoscopeType:=EndoScopeType_30;
	
	//endoscope posutre
	m_curEndoscopePosture :E_EndoscopePosture:=EndoscopePosture_HeadDown;
	m_nextEndoscopePosture :E_EndoscopePosture:=EndoscopePosture_HeadDown;
	
	// udint code for zero position
	m_zeroPosCode : UDINT;
	
	// joint4 zero position, which is supposed to be a contant value
	m_jnt4ZeroPos :LREAL := 5.7;
	
	//reset arm  LED flag
	m_resetArmLEDFlag : BOOL :=TRUE;
	
	// variables used to read instrument information
	m_Step:INT;
	m_Value:UDINT;
	m_ReadDelay:TON;
	m_DealyTime:TIME:=T#0.5S;
	m_IDReadResult:UDINT;
	m_IDResult:ULINT;
	m_SeriesReadResult:UDINT;
	m_PosReadResult:UDINT;
	m_PosL1,m_PosL2,m_PosL3:UDINT;
	m_signL1,m_signL2,m_signL3:UDINT;
	m_UsageReadResult:ULINT;
	m_InstruUsageToLED:ULINT;
	
	m_HaveRecord:BOOL;
	m_SdoWrite:FB_EcCoESdoWrite;
	m_SdoRead:FB_EcCoESdoRead;
	
	//variables used to read-write instrument number of use
	m_useNumStep : INT;
	m_ReadNumDelay:TON;
	m_useNumReadResult:ULINT;
	m_useNumSendToLED:ULINT;
	
	// rising edge generator for instrument information reading
	m_writeLDP:R_TRIG;
	m_SDOStep: INT;
	m_fbTon_Step: ARRAY[0..5] OF TON;
	value: ULINT;
END_VAR

]]></Declaration>
    <Implementation>
      <ST><![CDATA[]]></ST>
    </Implementation>
    <Folder Name="property" Id="{0a8fb492-92a9-43e3-bb30-cd59d3e0dbc3}" />
    <Method Name="addNumOfUseToChip" Id="{45df9b0c-f1a5-4111-8ced-4f96df9a6908}">
      <Declaration><![CDATA[METHOD PUBLIC addNumOfUseToChip : BOOL
VAR
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[value:=16#40000000;
addNumOfUseToChip:=FALSE;
m_SdoWrite(sNetId:= m_ArmNetId, nSlaveAddr:= m_JointInstruAddr, nSubIndex:= 0, nIndex:= 16#6094, pSrcBuf:= ADR(value), cbBufLen:= SIZEOF(value), bExecute:= TRUE, );
IF NOT m_SdoWrite.bBusy THEN
	m_SdoWrite(bExecute:=FALSE);
	addNumOfUseToChip:=TRUE;
END_IF

]]></ST>
      </Implementation>
    </Method>
    <Method Name="checkInstruType" Id="{23fa829e-a1f1-4e69-8458-d2d49d4ad5b2}">
      <Declaration><![CDATA[METHOD PROTECTED checkInstruType : BOOL
VAR_INPUT
END_VAR
VAR
	i:INT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// search instrument type
checkInstruType :=FALSE;
FOR i:=1 TO g_instruTypeNum DO 
	IF g_instruTypePool[i].m_InstruID = m_onChipData.m_InstruID THEN
		checkInstruType:=TRUE;
		m_instruTypeInfo := g_instruTypePool[i];
		EXIT;
	END_IF
END_FOR

// return directly if instrument ID is invalid
IF NOT(checkInstruType) THEN
	RETURN;
END_IF
m_instruType := m_onChipData.m_InstruID;

// update DH joint limit
m_wristMinDHJntPos[1]:=-m_instruTypeInfo.m_rollLimit;
m_wristMaxDHJntPos[1]:=m_instruTypeInfo.m_rollLimit;
m_wristMinDHJntPos[2]:=-m_instruTypeInfo.m_pitchLimit-pi/2;
m_wristMaxDHJntPos[2]:=m_instruTypeInfo.m_pitchLimit-pi/2;
m_wristMinDHJntPos[3]:=-m_instruTypeInfo.m_yawLimit;
m_wristMaxDHJntPos[3]:=m_instruTypeInfo.m_yawLimit;

]]></ST>
      </Implementation>
    </Method>
    <Method Name="clearNumOfUseToChip" Id="{66a2a0a0-abce-479d-99fc-1ac98d92da87}">
      <Declaration><![CDATA[METHOD PUBLIC clearNumOfUseToChip : BOOL
VAR
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[value:=16#80000000;
clearNumOfUseToChip:=FALSE;
m_SdoWrite(sNetId:= m_ArmNetId, nSlaveAddr:= m_JointInstruAddr, nSubIndex:= 0, nIndex:= 16#6094, pSrcBuf:= ADR(value), cbBufLen:= SIZEOF(value), bExecute:= TRUE, );
IF NOT m_SdoWrite.bBusy THEN
	m_SdoWrite(bExecute:=FALSE);
	clearNumOfUseToChip:=TRUE;
END_IF

]]></ST>
      </Implementation>
    </Method>
    <Property Name="curScopePosture" Id="{945bd074-db83-411c-b2b6-ba8fb40cb0da}" FolderPath="property\">
      <Declaration><![CDATA[PROPERTY curScopePosture : E_EndoscopePosture]]></Declaration>
      <Get Name="Get" Id="{823add43-d0d2-4f43-95d3-a4430d98cf46}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[curScopePosture:= m_curEndoscopePosture;]]></ST>
        </Implementation>
      </Get>
      <Set Name="Set" Id="{f17bc7af-661b-413a-b0a0-3bc4f2cce65c}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[m_curEndoscopePosture := curScopePosture;]]></ST>
        </Implementation>
      </Set>
    </Property>
    <Property Name="curScopeType" Id="{be0e16c9-fa0e-4a38-8e7b-5e33421408e0}" FolderPath="property\">
      <Declaration><![CDATA[PROPERTY curScopeType : E_EndoscopeType]]></Declaration>
      <Get Name="Get" Id="{e83d01a2-6478-4845-bac2-ef78ef4f4531}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[curScopeType := m_curEndoscopeType;]]></ST>
        </Implementation>
      </Get>
      <Set Name="Set" Id="{e4a3ed07-f2f6-4d92-a198-7650cdb8c844}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[m_curEndoscopeType := curScopeType;]]></ST>
        </Implementation>
      </Set>
    </Property>
    <Method Name="gripAngleMap" Id="{74c5b180-e560-4cf6-b54d-14953b80219a}">
      <Declaration><![CDATA[METHOD PUBLIC gripAngleMap : BOOL
VAR_INPUT
	// master gripper angle
	i_masterGripAng :LREAL;
END_VAR

VAR_OUTPUT
	// slave instrument gripper angle
	o_instruGripAngle :LREAL;
	
	// slave instrument grip force	
	o_instruGripForceLevel :LREAL;
END_VAR

VAR
	gripLevel :REAL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[// suppose finger is  closed and zero force if instrument has only one finger
IF m_instruTypeInfo.m_isSingleFinger THEN
	o_instruGripAngle := 0;
	o_instruGripForceLevel:= 0;
	RETURN;
END_IF 

// finger closed and force applied
IF i_masterGripAng < g_masterGripForceStartAng THEN
	o_instruGripAngle := g_minSlaveGripAngle;
	// NOTE: force is applied from 50%，as minimum gripper angle already apply some sort of force
	o_instruGripForceLevel := 50+50*(g_masterGripForceStartAng - i_masterGripAng)/(g_masterGripForceStartAng - g_minMasterGripAngle);
// finger open
ELSE
	o_instruGripAngle := (g_maxMasterGripAngle - i_masterGripAng)/(g_maxMasterGripAngle - g_masterGripForceStartAng);
	o_instruGripAngle :=m_instruTypeInfo.m_maxGripAngle - o_instruGripAngle * (m_instruTypeInfo.m_maxGripAngle - g_minSlaveGripAngle);
	o_instruGripAngle := LIMIT(g_minSlaveGripAngle, o_instruGripAngle, m_instruTypeInfo.m_maxGripAngle );
	o_instruGripForceLevel:=0;
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="init" Id="{9e715dac-d1e9-475d-b575-70936288e041}">
      <Declaration><![CDATA[METHOD PUBLIC init : BOOL
VAR_INPUT
	armIdx :INT;
END_VAR
VAR
	i:INT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[//Update the IP and port number of the operating arm
m_armNetId:=GVL_SlaveJointEncoderCaliData.g_slaveArmNetID[armIdx];
m_jointInstruAddr:=GVL_SlaveJointEncoderCaliData.g_slaveJointNetPort[armIdx,4];
m_LEDAddr := GVL_SlaveJointEncoderCaliData.g_slaveLEDNetPort[armIdx];

// init joint motion range
FOR i:=1 TO 3 DO
	m_wristMinDHJntPos[i]:=GVL_SlaveMotorParameters.g_minDHJntPos[i+3];
	m_wristMaxDHJntPos[i]:=GVL_SlaveMotorParameters.g_maxDHJntPos[i+3];
END_FOR
]]></ST>
      </Implementation>
    </Method>
    <Method Name="initInstruJntPos" Id="{896dfa6a-6aa4-49c1-b04e-03a7a450d473}">
      <Declaration><![CDATA[METHOD PUBLIC initInstruJntPos : BOOL
VAR_INPUT
	m_curJntPos :Vec8d;
END_VAR

VAR
	i:INT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[FOR i := 4 TO 8 BY 1 DO
	m_jntPosOffset[i]:=m_curJntPos[i];
END_FOR]]></ST>
      </Implementation>
    </Method>
    <Method Name="instruFK" Id="{01a436c8-6f9e-429f-819c-c3ae9a25ceb7}">
      <Declaration><![CDATA[// convert motor joint position to DH joint position
METHOD PUBLIC instruFK : BOOL
VAR_IN_OUT CONSTANT
	// motor joint position of slave arm
	i_jntPos :Vec8d;
END_VAR

VAR_IN_OUT
	// instrument DH  joint positon
	r_DHJntPos :Vec6d;

	// gripper angle
	r_gripAngle :LREAL;
END_VAR

VAR
	jntPosL1,jntPosL2,jntPosL3,jntPosL4,jntPosL5 :LREAL;
	gripAngle:LREAL;
	kx,ky,kz, k13, k23,openAngleDir:LREAL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[r_DHJntPos[1]:=i_jntPos[1];
r_DHJntPos[2]:=i_jntPos[2];
r_DHJntPos[3]:=i_jntPos[3];

// kinematic variables
openAngleDir:=-1;
kx:=-1;
ky:=m_instruTypeInfo.m_k2;
kz:=m_instruTypeInfo.m_k1;
k13:=m_instruTypeInfo.m_k3;
k23:=m_instruTypeInfo.m_k3;


// ################## endoscope ############################
IF m_instruType = InstruType_endoscope THEN
	r_DHJntPos[4]:=m_endoscopeRotateReduction*(i_jntPos[8]-m_jntPosOffset[8]);
	IF m_curEndoscopeType = EndoScopeType_30 THEN
		r_DHJntPos[5]:=-pi/2+30*g_deg2Rad;
	ELSE
		r_DHJntPos[5]:=-pi/2;
	END_IF
	r_DHJntPos[6]:=0;
	RETURN;
END_IF

// ################## ultrosonic knief ############################
IF m_instruType = InstruType_UltrasoundKnifeS OR m_instruType = InstruType_UltrasoundKnifeU THEN
	r_DHJntPos[4]:=-(i_jntPos[8]-m_jntPosOffset[8])/kx;
	r_DHJntPos[5]:=-pi/2;
	r_DHJntPos[6]:=0;
	r_gripAngle:=ultrasoundKnifeGripAngleFK(i_jntPos[6]-m_jntPosOffset[6]);
	RETURN;
END_IF


//#################### instrument forward kinematic ############
// convert motor joint position to instrument joint position
jntPosL1:=(i_jntPos[4]-m_jntPosOffset[4]);
jntPosL2:=(i_jntPos[5]-m_jntPosOffset[5]);
jntPosL3:=(i_jntPos[6]-m_jntPosOffset[6]);
jntPosL4:=-(i_jntPos[7]-m_jntPosOffset[7]);
jntPosL5:=-(i_jntPos[8]-m_jntPosOffset[8]);

// diable L1 if instrument is single finger
IF m_instruTypeInfo.m_isSingleFinger THEN
	jntPosL1 := -jntPosL2;
END_IF

// instrument FK in local coordinate
r_DHJntPos[4]:=jntPosL4/kx;
r_DHJntPos[5]:=jntPosL3/ky;
r_DHJntPos[6]:=(jntPosL1-jntPosL2-2*r_DHJntPos[5]*k13*kz)/(2*openAngleDir*kz);

// convert instrument rotation to arm DH joint position
r_DHJntPos[5]:=-r_DHJntPos[5]-pi/2;
r_DHJntPos[6]:=-r_DHJntPos[6];

// grip angle
gripAngle:=(jntPosL1+jntPosL2)/(openAngleDir*kz);

//################### gripper angle handle #################
IF (InstruType_ProGraspForceps=m_instruType OR InstruType_ForceBipolar=m_instruType) THEN//细齿无创抓钳
	proGrsapForcepsGripAngleFK(frontAngle:= gripAngle, endAngle=> r_gripAngle);

ELSIF (InstruType_CauteryHook = m_instruType OR InstruType_CauterySpatula = m_instruType) THEN//单级电钩
	r_gripAngle:=0;
ELSE
	r_gripAngle:=gripAngle;
END_IF

]]></ST>
      </Implementation>
    </Method>
    <Method Name="InstruIDRecord" Id="{5b4015f6-c1be-4c0d-8838-0164470db5ac}">
      <Declaration><![CDATA[METHOD PROTECTED InstruIDRecord :ARRAY [1..100] OF  ULINT
VAR_INPUT
	i_NewValue:ULINT;
	i_ArrayData:ARRAY [1..100] OF ULINT;
END_VAR

VAR
	k1:INT;
	Have_Data:BOOL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[FOR k1:= 1 TO 100 BY 1 DO
	IF i_NewValue=i_ArrayData[k1] THEN
		Have_Data:=TRUE;
		EXIT;
	ELSE
		Have_Data:=FALSE;
	END_IF
END_FOR

IF Have_Data=FALSE THEN
	FOR k1:= 1 TO 99 BY 1 DO
		InstruIDRecord[k1+1]:=i_ArrayData[k1];
	END_FOR
	InstruIDRecord[1]:=i_NewValue;
ELSE
	InstruIDRecord:=i_ArrayData ;
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="instruIK" Id="{6bf56e3f-7189-4e73-b1a2-93e24ad079df}">
      <Declaration><![CDATA[METHOD PUBLIC instruIK : BOOL
VAR_INPUT
	// DH  joint positon
	i_DHJntPos :Vec6d;

	// gripper angle
	i_gripAngle :LREAL;
	
END_VAR
VAR_OUTPUT
	o_jntPos:Vec8d;
END_VAR
VAR
	gripAngle:LREAL;
	i:INT;
	rot_x:lreal;
	rot_y:lreal;
	rot_z:lreal;

	kx,ky,kz,k13,k23:LREAL;
	d,ra:LREAL;
	
	m_gripAnglePbox:Vec8d;

END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[o_jntPos[1] := i_DHJntPos[1];
o_jntPos[2] := i_DHJntPos[2];
o_jntPos[3] := i_DHJntPos[3];

// kinematic variables
d:=-1;
kx:=-1;
ky:=m_instruTypeInfo.m_k2;
kz:=m_instruTypeInfo.m_k1;
k13:=m_instruTypeInfo.m_k3;
k23:=m_instruTypeInfo.m_k3;

// ################## endoscope ############################
IF m_instruType = InstruType_endoscope THEN
	o_jntPos[8] := i_DHJntPos[4]/m_endoscopeRotateReduction + m_jntPosOffset[8];
	o_jntPos[4]:=0;
	o_jntPos[5]:=0;
	o_jntPos[6]:=0;
	o_jntPos[7]:=0;
	RETURN;
END_IF

//################### gripper angle handle #################
IF (InstruType_ProGraspForceps=m_instruType OR InstruType_ForceBipolar=m_instruType) THEN//细齿无创抓钳
	proGrsapForcepsGripAngleIK(endAngle:= i_gripAngle, frontAngle=> gripAngle);
	
ELSIF (InstruType_CauteryHook = m_instruType OR InstruType_CauterySpatula = m_instruType)  THEN//单级电钩\电铲
	gripAngle:=0;
	
ELSE
	gripAngle:=i_gripAngle;
END_IF

// ################# instrument inverse kinematic ##############
// convert arm DH joint position to  instrument rotation
rot_x:=i_DHJntPos[4];
rot_y:=-i_DHJntPos[5]-pi/2;
rot_z:=-i_DHJntPos[6];

// ################## ultrosonic knief ############################
IF InstruType_UltrasoundKnifeS = onChipData.m_InstruID OR InstruType_UltrasoundKnifeU = onChipData.m_InstruID THEN
	m_gripAnglePbox[4]:=0;
	m_gripAnglePbox[5]:=0;
	m_gripAnglePbox[6]:=ultrasoundKnifeGripAngleIK(gripAngle); 
	m_gripAnglePbox[7]:=rot_x*kx;
	m_gripAnglePbox[8]:=rot_x*kx;
ELSE
	m_gripAnglePbox[7]:=rot_x*kx;
	m_gripAnglePbox[6]:=rot_y*ky;
	ra:=gripAngle;
	m_gripAnglePbox[4]:=rot_y*k13*kz+d*rot_z*kz+d*ra*kz/2;
	m_gripAnglePbox[5]:=-rot_y*k23*kz-d*rot_z*kz+d*ra*kz/2;
END_IF

// convert instrument joint position to motor joint position
o_jntPos[4] := m_gripAnglePbox[4] + m_jntPosOffset[4];
o_jntPos[5] := m_gripAnglePbox[5] + m_jntPosOffset[5];
o_jntPos[6] := m_gripAnglePbox[6] + m_jntPosOffset[6];
o_jntPos[7] := -m_gripAnglePbox[7] + m_jntPosOffset[7];
o_jntPos[8] := -m_gripAnglePbox[8] + m_jntPosOffset[8];


]]></ST>
      </Implementation>
    </Method>
    <Method Name="instruJntVelFK" Id="{f1893ae0-bfd0-4ffa-ae8d-b118c21a1100}">
      <Declaration><![CDATA[// convert motor joint velocity to DH joint velocity
METHOD PUBLIC instruJntVelFK : BOOL
VAR_IN_OUT CONSTANT
	// motor joint velocity of slave arm
	i_jntVel :Vec8d;
END_VAR

VAR_IN_OUT
	// instrument DH  joint velocity
	r_DHJntVel :Vec6d;
END_VAR

VAR
	kx,ky,kz, k13, k23,openAngleDir:LREAL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[r_DHJntVel[1]:=i_jntVel[1];
r_DHJntVel[2]:=i_jntVel[2];
r_DHJntVel[3]:=i_jntVel[3];

// kinematic variables
openAngleDir:=-1;
kx:=-1;
ky:=m_instruTypeInfo.m_k2;
kz:=m_instruTypeInfo.m_k1;
k13:=m_instruTypeInfo.m_k3;
k23:=m_instruTypeInfo.m_k3;

r_DHJntVel[4]:=-i_jntVel[7]/kx;
r_DHJntVel[5]:=i_jntVel[6]/ky;
r_DHJntVel[6]:=(i_jntVel[4]-i_jntVel[5]-2*r_DHJntVel[5]*k13*kz)/(2*openAngleDir*kz);
r_DHJntVel[5]:=-r_DHJntVel[5];
r_DHJntVel[6]:=-r_DHJntVel[6];]]></ST>
      </Implementation>
    </Method>
    <Method Name="InstruSreiesFind" Id="{e8f9037b-8500-46e1-89fd-c2c8431823e2}">
      <Declaration><![CDATA[METHOD PROTECTED InstruSreiesFind : BOOL
VAR_INPUT
	i_NewValue:ULINT;
	i_ArrayData:ARRAY [1..100] OF ULINT;
	
END_VAR

VAR
	k1:INT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[InstruSreiesFind:=FALSE;
FOR k1:= 1 TO 100 BY 1 DO
	IF i_NewValue=i_ArrayData[k1] THEN
		InstruSreiesFind:=TRUE;
		EXIT;
	ELSE
		InstruSreiesFind:=FALSE;
	END_IF
END_FOR
]]></ST>
      </Implementation>
    </Method>
    <Property Name="instruType" Id="{8608d8dd-55f9-4f0f-9c69-67fbd12e9837}" FolderPath="property\">
      <Declaration><![CDATA[PROPERTY PUBLIC instruType : E_InstrumentType]]></Declaration>
      <Get Name="Get" Id="{d3e5ec89-2460-4d36-a458-4980216773ae}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[instruType := m_instruType;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Property Name="instruTypeInfo" Id="{fa5925fc-a39b-4326-a5f7-5bb7d26adb85}" FolderPath="property\">
      <Declaration><![CDATA[PROPERTY instruTypeInfo :REFERENCE TO ST_InstruTypeInfo]]></Declaration>
      <Get Name="Get" Id="{3eb49145-adc4-4b01-a1c9-55324e642edb}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[instruTypeInfo ref=m_instruTypeInfo;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Property Name="nextScopePosture" Id="{c68d7416-7c8e-4254-80e3-ba9aff466af0}" FolderPath="property\">
      <Declaration><![CDATA[PROPERTY nextScopePosture : E_EndoscopePosture]]></Declaration>
      <Get Name="Get" Id="{dcc9013d-5954-4fb9-ad29-0211fc9c0ee9}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[nextScopePosture:= m_nextEndoscopePosture;]]></ST>
        </Implementation>
      </Get>
      <Set Name="Set" Id="{4c7a5823-28ff-415f-baf4-96cb5ed118b6}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[m_nextEndoscopePosture := nextScopePosture;]]></ST>
        </Implementation>
      </Set>
    </Property>
    <Property Name="nextScopeType" Id="{f8bd8439-84aa-45e3-abfa-f08ae5014a86}" FolderPath="property\">
      <Declaration><![CDATA[PROPERTY nextScopeType : E_EndoscopePosture]]></Declaration>
      <Get Name="Get" Id="{9480ba7c-e2b2-4bf3-badb-40a6c02f5154}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[nextScopeType:= m_nextEndoscopeType;]]></ST>
        </Implementation>
      </Get>
      <Set Name="Set" Id="{05bd18ee-b0e9-4be3-9c8d-e6995dea4405}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[m_nextEndoscopeType := nextScopeType;]]></ST>
        </Implementation>
      </Set>
    </Property>
    <Property Name="onChipData" Id="{57faf196-74d1-44be-bdda-05314fcf13d1}" FolderPath="property\">
      <Declaration><![CDATA[PROPERTY onChipData : REFERENCE TO ST_InstruOnChipData]]></Declaration>
      <Get Name="Get" Id="{38f32311-c804-4f34-b2c8-ea86671bc8a1}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[onChipData ref=m_onChipData;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Method Name="proGrsapForcepsGripAngleFK" Id="{4337dcc5-1ab3-41ab-b451-5d33bf84654b}">
      <Declaration><![CDATA[METHOD PROTECTED proGrsapForcepsGripAngleFK : BOOL
VAR_INPUT
	frontAngle:LREAL;
END_VAR
VAR_OUTPUT
	endAngle:LREAL;
	Succeed:BOOL;
END_VAR
VAR
	// prograsp data
	AB :LREAL := 2.8;
	BC:LREAL := 5.26;
	initA:LREAL := 16.6 * g_deg2Rad; 
	initC:LREAL := 8.75*g_deg2Rad;
	
	SIN_C,Angle_Inc_C,Angle_C,Angle_A,Angle_Inc_A:LREAL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[//**************已知：器械前端开合角，求解：末端开合角***************//
// determine prograsp type data
IF InstruType_ProGraspForceps=m_instruType THEN
	AB:=g_proGraspAB;
	BC:=g_proGraspBC;
	initA := g_proGraspInitA;
	initC := g_proGraspInitC;
ELSIF InstruType_ForceBipolar=m_instruType THEN
	AB:=g_proGrasp2AB;
	BC:=g_proGrasp2BC;
	initA := g_proGrasp2InitA;
	initC := g_proGrasp2InitC;
END_IF

Angle_Inc_A:=frontAngle/2;
Angle_A:=initA+Angle_Inc_A;
Angle_A := LIMIT(0.0, Angle_A, pi);

SIN_C:=AB*SIN(Angle_A)/BC;
Angle_C:=ASIN(SIN_C);

Angle_Inc_C:=Angle_C-initC;
endAngle:=Angle_Inc_C*2;]]></ST>
      </Implementation>
    </Method>
    <Method Name="proGrsapForcepsGripAngleIK" Id="{5e3269e8-209c-4f7f-bd35-977efcc97c73}">
      <Declaration><![CDATA[METHOD PROTECTED proGrsapForcepsGripAngleIK : BOOL
VAR_INPUT
	endAngle:LREAL;
END_VAR
VAR_OUTPUT
	frontAngle:LREAL;
	Succeed:BOOL;
END_VAR
VAR
	AB :LREAL := 2.8;
	BC:LREAL := 5.26;
	initA:LREAL := 16.6 * g_deg2Rad; 
	initC:LREAL := 8.75*g_deg2Rad;
	Angle_Inc_C,Angle_C,SIN_A,Angle_A,Angle_Inc_A:LREAL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[//***************已知：器械末端开合角，求解：前端开合角********************//
// determine prograsp type data
IF InstruType_ProGraspForceps=m_instruType THEN
	AB:=g_proGraspAB;
	BC:=g_proGraspBC;
	initA := g_proGraspInitA;
	initC := g_proGraspInitC;
ELSIF InstruType_ForceBipolar=m_instruType THEN
	AB:=g_proGrasp2AB;
	BC:=g_proGrasp2BC;
	initA := g_proGrasp2InitA;
	initC := g_proGrasp2InitC;
END_IF

Angle_Inc_C:=endAngle/2;
Angle_C:=initC+Angle_Inc_C;
Angle_C := LIMIT(0, Angle_C, pi);

SIN_A:=BC*SIN(Angle_C)/AB;
Angle_A:=ASIN(SIN_A);

Angle_Inc_A:=Angle_A-initA;
frontAngle:=Angle_Inc_A*2;]]></ST>
      </Implementation>
    </Method>
    <Method Name="readParameters" Id="{1ea42647-1cdf-4880-8b6e-e43d06de3874}">
      <Declaration><![CDATA[METHOD PUBLIC readParameters : BOOL
VAR_INPUT
	startFlag :BOOL;
END_VAR

VAR
	paramIdx :INT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[// TODO: read m_kinematic parameters from chip 
//Take the rising edge of the read signal
m_ReadDelay(IN:= m_Step=10, PT:= m_DealyTime, Q=> , ET=> );//计时器
IF startFlag AND m_curReadTries < m_maxReadTries THEN
	m_Step:=0;
	m_onChipData.m_InstruReadSucceed:=FALSE;
	m_onChipData.m_Error:=FALSE;
	m_onChipData.m_ErrorID:=0;
	m_resetArmLEDFlag :=TRUE;
END_IF


CASE m_Step OF
	
	0://向6093发送0x8000  0000---发送读取信号
		m_Value:=16#80000000; 
		m_SdoWrite(sNetId:= m_ArmNetId, nSlaveAddr:= m_JointInstruAddr, nSubIndex:= 0, nIndex:= 16#6093, pSrcBuf:= ADR(m_Value), cbBufLen:= SIZEOF(m_Value), bExecute:= TRUE, );
		IF NOT m_SdoWrite.bBusy THEN
			m_SdoWrite(bExecute:=FALSE);
			m_Step:=10;
		END_IF
		
		
	10://延时0.5s、防止值还没有返回
		IF m_ReadDelay.Q THEN
			m_Step:=20;
		END_IF

		
	20://从6093地址中拿值
		m_SdoRead(sNetId:= m_ArmNetId, nSlaveAddr:= m_JointInstruAddr,	nSubIndex:= 0, nIndex:= 16#6093, pDstBuf:= ADR(m_IDReadResult), cbBufLen:= SIZEOF(m_IDReadResult), bExecute:= TRUE, 	tTimeout:= , bBusy=> , bError=> , nErrId=> , cbRead=> );
		IF NOT m_SdoRead.bBusy THEN
			m_SdoRead(bExecute:=FALSE);
			m_Step:=30;
		END_IF	
		
	
	30://处理器械ID、低16位
		m_IDResult:=UDINT_TO_ULINT(16#0000FFFF AND m_IDReadResult);
		m_Step:=40;
		
		
	40://读取6095、器械序列号
		m_SdoRead(sNetId:= m_ArmNetId, nSlaveAddr:= m_JointInstruAddr,	nSubIndex:= 0, nIndex:= 16#6095, pDstBuf:= ADR(m_SeriesReadResult), cbBufLen:= SIZEOF(m_SeriesReadResult), bExecute:= TRUE, 	tTimeout:= , bBusy=> , bError=> , nErrId=> , cbRead=> );
		IF NOT m_SdoRead.bBusy THEN
			m_SdoRead(bExecute:=FALSE);
			m_Step:=50;
		END_IF	
	
		
	50://处理序列号，低30位
		m_onChipData.m_InstruseriesNum:=SHL(m_IDResult,31)+(16#7FFFFFFF AND m_SeriesReadResult);
		m_onChipData.m_InstruID:=LREAL_TO_INT(FLOOR(lr_in:= m_onChipData.m_InstruseriesNum/EXPT(10,9))); //取十进制前三位为器械ID
		m_Step:=60;
		
		
	60://读取6096---器械零点位置
		m_SdoRead(sNetId:= m_ArmNetId, nSlaveAddr:= m_JointInstruAddr,	nSubIndex:= 0, nIndex:= 16#6096, pDstBuf:= ADR(m_PosReadResult), cbBufLen:= SIZEOF(m_PosReadResult), bExecute:= TRUE, 	tTimeout:= , bBusy=> , bError=> , nErrId=> , cbRead=> );
		IF NOT m_SdoRead.bBusy THEN
			m_SdoRead(bExecute:=FALSE);
			m_Step:=70;
		END_IF	
		
		
	70: //处理位置，L1:0-9位，L2:10-19位，L3:20-29位
		zeroPosDecode(m_PosReadResult, o_q1=>m_onChipData.m_InstruPos[1],o_q2=>m_onChipData.m_InstruPos[2],o_q3=>m_onChipData.m_InstruPos[3]);
		m_onChipData.m_InstruPos[4] := m_jnt4ZeroPos;
		m_onChipData.m_InstruPos[5] := 0;
		
		m_Step:=80;
		
	80://读取器械使用次数 6094
		m_SdoRead(sNetId:= m_ArmNetId, nSlaveAddr:= m_JointInstruAddr,	nSubIndex:= 0, nIndex:= 16#6094, pDstBuf:= ADR(m_UsageReadResult), cbBufLen:= SIZEOF(m_UsageReadResult), bExecute:= TRUE, 	tTimeout:= , bBusy=> , bError=> , nErrId=> , cbRead=> );
		IF NOT m_SdoRead.bBusy THEN
			m_SdoRead(bExecute:=FALSE);
			m_Step:=90;
		END_IF	
		
		
	90://处理器械使用次数读取结果
		m_onChipData.m_InstruusageCounts:=m_UsageReadResult;
		m_InstruUsageToLED:=LIMIT(0,m_UsageReadResult,99);
		m_Step:=100;
		
		
	100://将器械使用次数写入LED
		m_Value:=ULINT_TO_UDINT(16#FFFF AND m_InstruUsageToLED) ;
		m_SdoWrite(sNetId:= m_ArmNetId, nSlaveAddr:= m_LEDAddr, nSubIndex:= 06, nIndex:= 16#6090, pSrcBuf:= ADR(m_Value), cbBufLen:= SIZEOF(m_Value), bExecute:= TRUE, tTimeout:= , bBusy=> , bError=> , nErrId=> );
		IF NOT m_SdoWrite.bBusy THEN
			m_SdoWrite(bExecute:=FALSE);
			m_Step:=110;
		END_IF
		
	110:
		// get insturment typeinfo
		m_onChipData.m_InstruReadSucceed:=checkInstruType();
		
		//结果诊断
		m_onChipData.m_ErrorID:=0;
		IF NOT(m_onChipData.m_InstruReadSucceed) THEN
			m_onChipData.m_Error:=TRUE;
			m_onChipData.m_ErrorID:=1;
			
//		ELSIF SlaveArmControl.m_slaveRobot.m_endoscopeMounted AND m_instruType = InstruType_Endoscope THEN
//			m_onChipData.m_InstruReadSucceed := FALSE;
//			m_onChipData.m_Error:=TRUE;
//			m_onChipData.m_ErrorID:=3;
			
//		ELSIF m_onChipData.m_InstruusageCounts>(m_instruTypeInfo.m_maxUseNum -1) AND m_instruType<>InstruType_Endoscope THEN
//			m_HaveRecord:=InstruSreiesFind(i_NewValue:=m_onChipData.m_InstruseriesNum , i_ArrayData:=GVL_interactUI.g_InstruSeriesRecord );
//			IF m_HaveRecord THEN
//				//
//			ELSE
//				m_onChipData.m_InstruReadSucceed := FALSE; 
//				m_onChipData.m_Error:=TRUE;
//				m_onChipData.m_ErrorID:=2;
//			END_IF
		END_IF
		
		//处理当器械使用次数达到上限后、在同一场手术中还能使用
//		IF m_onChipData.m_InstruReadSucceed AND m_onChipData.m_InstruusageCounts=(m_instruTypeInfo.m_maxUseNum -1) THEN		
//			//TODO: check this part
//			GVL_interactUI.g_InstruSeriesRecord:=InstruIDRecord(i_NewValue:= m_onChipData.m_InstruseriesNum, i_ArrayData:= GVL_interactUI.g_InstruSeriesRecord);
//		END_IF
		
		m_Step :=-1;
		m_curReadTries := m_curReadTries +1;
	
END_CASE]]></ST>
      </Implementation>
    </Method>
    <Method Name="reset" Id="{2150938d-7491-43bf-8cee-11d7c2d853d8}">
      <Declaration><![CDATA[METHOD PUBLIC reset : BOOL
VAR_INPUT
END_VAR
VAR
	i:INT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[m_Step := -1;
m_curReadTries := 0;
m_onChipData.m_InstruID := 0;
m_onChipData.m_InstruseriesNum :=0;
m_onChipData.m_Error:=FALSE;
m_onChipData.m_ErrorID:=0;
m_onChipData.m_InstruReadSucceed:=FALSE;
m_instruType:=InstruType_UNKNOWM;

FOR i:= 4 TO 8 BY 1 DO
	m_jntPosOffset[i]:=0;
END_FOR

// init joint motion range
FOR i:=1 TO 3 DO
	m_wristMinDHJntPos[i]:=GVL_SlaveMotorParameters.g_minDHJntPos[i+3];
	m_wristMaxDHJntPos[i]:=GVL_SlaveMotorParameters.g_maxDHJntPos[i+3];
END_FOR

// reset endoscope type and posture
m_curEndoscopeType :=EndoScopeType_30;
m_nextEndoscopeType :=EndoScopeType_30;
m_curEndoscopePosture :=EndoscopePosture_HeadDown;
m_nextEndoscopePosture :=EndoscopePosture_HeadDown;

//arm LED reset
IF m_resetArmLEDFlag THEN
	m_Value:=0 ;
	m_SdoWrite(sNetId:= m_ArmNetId, nSlaveAddr:= m_LEDAddr, nSubIndex:= 06, nIndex:= 16#6090, pSrcBuf:= ADR(m_Value), cbBufLen:= SIZEOF(m_Value), bExecute:= TRUE, tTimeout:= , bBusy=> , bError=> , nErrId=> );
END_IF
IF NOT m_SdoWrite.bBusy THEN
	m_SdoWrite(bExecute:=FALSE);
	m_resetArmLEDFlag := FALSE;
END_IF

]]></ST>
      </Implementation>
    </Method>
    <Property Name="resetArmLED" Id="{55c3281e-2652-4243-8250-a72a78fa0e9b}" FolderPath="property\">
      <Declaration><![CDATA[PROPERTY resetArmLED : BOOL]]></Declaration>
      <Set Name="Set" Id="{bb227761-ae9d-43ba-8672-13b8d109fa00}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[m_resetArmLEDFlag := resetArmLED;]]></ST>
        </Implementation>
      </Set>
    </Property>
    <Method Name="ultrasoundKnifeGripAngleFK" Id="{ca2c3cd5-81e6-42a6-bf33-36ac1f09c9ab}">
      <Declaration><![CDATA[METHOD ultrasoundKnifeGripAngleFK : LREAL
VAR_INPUT
	// motor joint position of slave arm
	i_jntPos :LREAL;
END_VAR

VAR
	m_jntPos : LREAL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[m_jntPos := i_jntPos;

m_jntPos := LIMIT (-20*g_deg2Rad,m_jntPos,70*g_deg2Rad);

ultrasoundKnifeGripAngleFK := ASIN((m_jntPos*g_uknifeMotorLead * g_uknifeLeverRatio/(2*pi) -  g_uknifeGripTravel * SIN(g_uknifeGripDividAngle))/g_uknifeGripTravel)+g_uknifeGripDividAngle;]]></ST>
      </Implementation>
    </Method>
    <Method Name="ultrasoundKnifeGripAngleIK" Id="{6c2303ef-3280-4024-a48d-07991b64212d}">
      <Declaration><![CDATA[METHOD ultrasoundKnifeGripAngleIK : LREAL
VAR_INPUT
	// gripper angle
	i_gripAngle :LREAL;
END_VAR

VAR
	m_gripAngle : LREAL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[m_gripAngle := i_gripAngle;

ultrasoundKnifeGripAngleIK := (g_uknifeGripTravel * (SIN(g_uknifeGripDividAngle) - SIN(g_uknifeGripDividAngle - m_gripAngle))/(g_uknifeMotorLead*g_uknifeLeverRatio/(2*pi)));]]></ST>
      </Implementation>
    </Method>
    <Method Name="writeNumOfUseToChip" Id="{07a44639-b39b-4ce4-9f1a-34991f73198d}">
      <Declaration><![CDATA[METHOD writeNumOfUseToChip : BOOL
VAR_INPUT
	startFlag :BOOL;
	i_useNumFromUI :UINT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[writeNumOfUseToChip := FALSE;
m_writeLDP(CLK:= startFlag, Q=> );
m_ReadNumDelay(IN:= m_useNumStep = 10, PT:= m_DealyTime, Q=> , ET=> );
IF m_writeLDP.Q THEN
	m_useNumStep:=0;
END_IF

CASE m_useNumStep OF
	0: 
		m_Value:=16#80000000; 
		m_SdoWrite(sNetId:= m_ArmNetId, nSlaveAddr:= m_JointInstruAddr, nSubIndex:= 0, nIndex:= 16#6094, pSrcBuf:= ADR(m_Value), cbBufLen:= SIZEOF(m_Value), bExecute:= TRUE, );
		IF NOT m_SdoWrite.bBusy THEN
			m_SdoWrite(bExecute:=FALSE);
			m_useNumStep:=10;
		END_IF
	
	10:
		IF m_ReadNumDelay.Q THEN
			m_useNumStep:=20;
		END_IF
		
	20:
		m_SdoRead(sNetId:= m_ArmNetId, nSlaveAddr:= m_JointInstruAddr,	nSubIndex:= 0, nIndex:= 16#6094, pDstBuf:= ADR(m_useNumReadResult), cbBufLen:= SIZEOF(m_useNumReadResult), bExecute:= TRUE, 	tTimeout:= , bBusy=> , bError=> , nErrId=> , cbRead=> );
		IF NOT m_SdoRead.bBusy THEN
			m_SdoRead(bExecute:=FALSE);
			m_useNumStep:=30;
		END_IF
		
	30://Verify the actual usage count and the usage count given by the UI
		IF m_useNumReadResult = i_useNumFromUI THEN
			m_useNumSendToLED := LIMIT(0, m_useNumReadResult, 99);
			m_useNumStep:=40;
		ELSE
			m_useNumStep:=50;
		END_IF
		
	40: 
		m_Value:=ULINT_TO_UDINT( m_useNumSendToLED) ;
		m_SdoWrite(sNetId:= m_ArmNetId, nSlaveAddr:= m_LEDAddr, nSubIndex:= 06, nIndex:= 16#6090, pSrcBuf:= ADR(m_Value), cbBufLen:= SIZEOF(m_Value), bExecute:= TRUE, tTimeout:= , bBusy=> , bError=> , nErrId=> );
		IF NOT m_SdoWrite.bBusy THEN
			m_SdoWrite(bExecute:=FALSE);
			m_onChipData.m_InstruUsageCounts:=m_useNumReadResult;
			writeNumOfUseToChip := TRUE;
			m_useNumStep:=-1;
		END_IF
		
END_CASE]]></ST>
      </Implementation>
    </Method>
    <Method Name="writeSNToChip" Id="{83a532fd-275d-44b8-b8ab-c7e1f43e9534}">
      <Declaration><![CDATA[METHOD writeSNToChip : BOOL
VAR_INPUT
	newSNNum : ULINT;
END_VAR
VAR
	
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// TODO
m_fbTon_Step[1](IN:=m_SDOStep=5 , PT:= T#1S, Q=> , ET=> );
m_fbTon_Step[2](IN:=m_SDOStep=15 , PT:= T#1S, Q=> , ET=> );
CASE m_SDOStep OF
	0: 
	  value:=(newSNNum AND 16#7FFFFFFF)OR 16#80000000;
	  m_SDOStep:=5;
	5:	
	  m_SdoWrite(sNetId:= m_ArmNetId, nSlaveAddr:= m_JointInstruAddr, nSubIndex:= 0, nIndex:= 16#6095, pSrcBuf:= ADR(value), cbBufLen:= SIZEOF(value), bExecute:= TRUE, );
	  IF NOT m_SdoWrite.bBusy AND m_fbTon_Step[1].Q THEN
		  m_SdoWrite(bExecute:=FALSE);
		  m_SDOStep:=10;
	  END_IF
	10:
	  value:=SHR(newSNNum,31)OR 16#10000;
	  m_SDOStep:=15;
	15: 
	  m_SdoWrite(sNetId:= m_ArmNetId, nSlaveAddr:= m_JointInstruAddr, nSubIndex:= 0, nIndex:= 16#6093, pSrcBuf:= ADR(value), cbBufLen:= SIZEOF(value), bExecute:= TRUE, );
	  IF NOT m_SdoWrite.bBusy AND m_fbTon_Step[2].Q THEN
		  m_SdoWrite(bExecute:=FALSE);
		  writeSNToChip:=TRUE;
		  m_SDOStep:=0;
	  END_IF
END_CASE]]></ST>
      </Implementation>
    </Method>
    <Method Name="writeZeroPosToChip" Id="{a3e7c3ba-796b-487c-a2b3-eea47070c654}">
      <Declaration><![CDATA[METHOD PUBLIC writeZeroPosToChip : BOOL
VAR_INPUT
	i_q1:LREAL;
	i_q2:LREAL;
	i_q3:LREAL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[zeroPosCode(i_q1,i_q2,i_q3, o_code=>m_zeroPosCode);

writeZeroPosToChip:=FALSE;
m_SdoWrite(sNetId:= m_ArmNetId, nSlaveAddr:= m_JointInstruAddr, nSubIndex:= 0, nIndex:= 16#6096, pSrcBuf:= ADR(m_zeroPosCode), cbBufLen:= SIZEOF(m_zeroPosCode), bExecute:= TRUE, );
IF NOT m_SdoWrite.bBusy THEN
	m_SdoWrite(bExecute:=FALSE);
	writeZeroPosToChip:=TRUE;
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="zeroPosCode" Id="{9cc3be0b-4ba3-41cd-ac21-cc489d7a0f62}">
      <Declaration><![CDATA[// code instrument joints(4/5/6) zero position as a UDINT
// joint1 : bit 21-30; joint2: bit 11-20; joint3: bit1-10
// zeroPos: [0, 2pi]; code:[0-3sFF]
METHOD PROTECTED zeroPosCode : BOOL
VAR_INPUT
	i_q1:LREAL;
	i_q2:LREAL;
	i_q3:LREAL;
END_VAR
VAR_OUTPUT
	o_code:UDINT;
END_VAR
VAR
	posCode:UDINT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// highest bit set to 1
o_code:=2;

// joint1
posCode := LREAL_TO_UDINT(16#3FF * LIMIT(0,i_q1/g_2pi,1));
o_code := SHL(o_code, 10);
o_code := o_code OR posCode;

// joint2
posCode := LREAL_TO_UDINT(16#3FF * LIMIT(0,i_q2/g_2pi,1));
o_code := SHL(o_code, 10);
o_code := o_code OR posCode;

// joint3
posCode := LREAL_TO_UDINT(16#3FF * LIMIT(0,i_q3/g_2pi,1));
o_code := SHL(o_code, 10);
o_code := o_code OR posCode;]]></ST>
      </Implementation>
    </Method>
    <Method Name="zeroPosDecode" Id="{bbd3ba7d-ee43-477b-a6ee-704c2e0c1c3d}">
      <Declaration><![CDATA[// decode instrument joints(4/5/6) zero position from a UDINT
// joint1 : bit 21-30; joint2: bit 11-20; joint4: bit1-10
// zeroPos: [0, 2pi]; code:[0-2FF]
METHOD PROTECTED zeroPosDecode : BOOL
VAR_INPUT
	i_posCode :UDINT;
END_VAR
VAR_OUTPUT
	o_q1:LREAL;
	o_q2:LREAL;
	o_q3:LREAL;
END_VAR
VAR
	posCode:UDINT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// joint3
posCode := i_posCode AND 16#3FF;
o_q3 := g_2pi *  posCode/16#3FF;

// joint2
i_posCode := SHR(i_posCode, 10);
posCode := i_posCode AND 16#3FF;
o_q2 := g_2pi *  posCode/16#3FF;

// joint1
i_posCode := SHR(i_posCode, 10);
posCode := i_posCode AND 16#3FF;
o_q1 := g_2pi *  posCode/16#3FF;
]]></ST>
      </Implementation>
    </Method>
    <LineIds Name="FB_Instrument">
      <LineId Id="9" Count="0" />
    </LineIds>
    <LineIds Name="FB_Instrument.addNumOfUseToChip">
      <LineId Id="25" Count="0" />
      <LineId Id="17" Count="4" />
      <LineId Id="5" Count="0" />
      <LineId Id="59" Count="0" />
      <LineId Id="32" Count="0" />
    </LineIds>
    <LineIds Name="FB_Instrument.checkInstruType">
      <LineId Id="468" Count="0" />
      <LineId Id="541" Count="0" />
      <LineId Id="534" Count="1" />
      <LineId Id="537" Count="0" />
      <LineId Id="539" Count="1" />
      <LineId Id="538" Count="0" />
      <LineId Id="536" Count="0" />
      <LineId Id="476" Count="1" />
      <LineId Id="479" Count="2" />
      <LineId Id="542" Count="0" />
      <LineId Id="503" Count="1" />
      <LineId Id="518" Count="5" />
      <LineId Id="527" Count="0" />
      <LineId Id="18" Count="0" />
    </LineIds>
    <LineIds Name="FB_Instrument.clearNumOfUseToChip">
      <LineId Id="25" Count="0" />
      <LineId Id="17" Count="4" />
      <LineId Id="5" Count="0" />
      <LineId Id="59" Count="0" />
      <LineId Id="32" Count="0" />
    </LineIds>
    <LineIds Name="FB_Instrument.curScopePosture.Get">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_Instrument.curScopePosture.Set">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_Instrument.curScopeType.Get">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_Instrument.curScopeType.Set">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_Instrument.gripAngleMap">
      <LineId Id="103" Count="17" />
      <LineId Id="24" Count="0" />
    </LineIds>
    <LineIds Name="FB_Instrument.init">
      <LineId Id="7" Count="1" />
      <LineId Id="5" Count="0" />
      <LineId Id="30" Count="0" />
      <LineId Id="22" Count="0" />
      <LineId Id="18" Count="0" />
      <LineId Id="17" Count="0" />
      <LineId Id="19" Count="0" />
      <LineId Id="21" Count="0" />
      <LineId Id="20" Count="0" />
      <LineId Id="13" Count="0" />
    </LineIds>
    <LineIds Name="FB_Instrument.initInstruJntPos">
      <LineId Id="5" Count="0" />
      <LineId Id="11" Count="1" />
    </LineIds>
    <LineIds Name="FB_Instrument.instruFK">
      <LineId Id="425" Count="2" />
      <LineId Id="507" Count="0" />
      <LineId Id="506" Count="0" />
      <LineId Id="510" Count="0" />
      <LineId Id="508" Count="0" />
      <LineId Id="511" Count="3" />
      <LineId Id="509" Count="0" />
      <LineId Id="428" Count="57" />
      <LineId Id="159" Count="0" />
    </LineIds>
    <LineIds Name="FB_Instrument.InstruIDRecord">
      <LineId Id="13" Count="15" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_Instrument.instruIK">
      <LineId Id="589" Count="2" />
      <LineId Id="682" Count="6" />
      <LineId Id="681" Count="0" />
      <LineId Id="592" Count="26" />
      <LineId Id="627" Count="23" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_Instrument.instruJntVelFK">
      <LineId Id="131" Count="0" />
      <LineId Id="134" Count="1" />
      <LineId Id="239" Count="6" />
      <LineId Id="238" Count="0" />
      <LineId Id="200" Count="3" />
      <LineId Id="159" Count="0" />
      <LineId Id="220" Count="0" />
    </LineIds>
    <LineIds Name="FB_Instrument.InstruSreiesFind">
      <LineId Id="34" Count="8" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_Instrument.instruType.Get">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_Instrument.instruTypeInfo.Get">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_Instrument.nextScopePosture.Get">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_Instrument.nextScopePosture.Set">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_Instrument.nextScopeType.Get">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_Instrument.nextScopeType.Set">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_Instrument.onChipData.Get">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_Instrument.proGrsapForcepsGripAngleFK">
      <LineId Id="7" Count="0" />
      <LineId Id="65" Count="1" />
      <LineId Id="69" Count="3" />
      <LineId Id="67" Count="0" />
      <LineId Id="74" Count="2" />
      <LineId Id="73" Count="0" />
      <LineId Id="68" Count="0" />
      <LineId Id="77" Count="0" />
      <LineId Id="23" Count="1" />
      <LineId Id="61" Count="0" />
      <LineId Id="25" Count="5" />
    </LineIds>
    <LineIds Name="FB_Instrument.proGrsapForcepsGripAngleIK">
      <LineId Id="13" Count="0" />
      <LineId Id="73" Count="10" />
      <LineId Id="72" Count="0" />
      <LineId Id="84" Count="0" />
      <LineId Id="28" Count="0" />
      <LineId Id="30" Count="0" />
      <LineId Id="71" Count="0" />
      <LineId Id="31" Count="5" />
    </LineIds>
    <LineIds Name="FB_Instrument.readParameters">
      <LineId Id="1095" Count="93" />
      <LineId Id="1239" Count="2" />
      <LineId Id="1238" Count="0" />
      <LineId Id="1200" Count="19" />
      <LineId Id="1242" Count="0" />
      <LineId Id="1244" Count="3" />
      <LineId Id="1243" Count="0" />
      <LineId Id="1248" Count="0" />
      <LineId Id="1220" Count="2" />
      <LineId Id="28" Count="0" />
    </LineIds>
    <LineIds Name="FB_Instrument.reset">
      <LineId Id="51" Count="1" />
      <LineId Id="5" Count="1" />
      <LineId Id="11" Count="1" />
      <LineId Id="16" Count="0" />
      <LineId Id="59" Count="0" />
      <LineId Id="26" Count="0" />
      <LineId Id="22" Count="1" />
      <LineId Id="21" Count="0" />
      <LineId Id="41" Count="4" />
      <LineId Id="39" Count="0" />
      <LineId Id="73" Count="0" />
      <LineId Id="66" Count="0" />
      <LineId Id="68" Count="1" />
      <LineId Id="72" Count="0" />
      <LineId Id="65" Count="0" />
      <LineId Id="86" Count="0" />
      <LineId Id="85" Count="0" />
      <LineId Id="93" Count="0" />
      <LineId Id="102" Count="1" />
      <LineId Id="121" Count="2" />
      <LineId Id="131" Count="0" />
      <LineId Id="113" Count="0" />
      <LineId Id="87" Count="0" />
      <LineId Id="17" Count="0" />
    </LineIds>
    <LineIds Name="FB_Instrument.resetArmLED.Set">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_Instrument.ultrasoundKnifeGripAngleFK">
      <LineId Id="4" Count="3" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_Instrument.ultrasoundKnifeGripAngleIK">
      <LineId Id="4" Count="1" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_Instrument.writeNumOfUseToChip">
      <LineId Id="74" Count="45" />
      <LineId Id="16" Count="0" />
    </LineIds>
    <LineIds Name="FB_Instrument.writeSNToChip">
      <LineId Id="176" Count="22" />
      <LineId Id="10" Count="0" />
    </LineIds>
    <LineIds Name="FB_Instrument.writeZeroPosToChip">
      <LineId Id="16" Count="0" />
      <LineId Id="25" Count="0" />
      <LineId Id="17" Count="4" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_Instrument.zeroPosCode">
      <LineId Id="138" Count="15" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_Instrument.zeroPosDecode">
      <LineId Id="40" Count="0" />
      <LineId Id="45" Count="0" />
      <LineId Id="63" Count="0" />
      <LineId Id="58" Count="0" />
      <LineId Id="51" Count="0" />
      <LineId Id="64" Count="0" />
      <LineId Id="66" Count="0" />
      <LineId Id="65" Count="0" />
      <LineId Id="68" Count="3" />
      <LineId Id="67" Count="0" />
      <LineId Id="5" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>